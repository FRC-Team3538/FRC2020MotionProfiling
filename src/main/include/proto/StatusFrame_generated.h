// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STATUSFRAME_RJ_H_
#define FLATBUFFERS_GENERATED_STATUSFRAME_RJ_H_

#include "flatbuffers/flatbuffers.h"

namespace rj {

struct CTREMotorStatusFrame;

struct StatusFrameCollection;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) CTREMotorStatusFrame FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t firmwareVersion_;
  int32_t baseID_;
  int32_t deviceID_;
  int32_t padding0__;
  double outputCurrent_;
  double busVoltage_;
  double outputPercent_;
  double outputVoltage_;
  double temperature_;
  int32_t selectedSensorPosition_;
  int32_t selectedSensorVelocity_;
  int32_t closedLoopError_;
  int32_t padding1__;
  double integralAccumulator_;
  double errorDerivative_;
  double closedLoopTarget_;
  int32_t activeTrajectoryPosition_;
  int32_t activeTrajectoryVelocity_;
  double activeTrajectoryArbFeedFwd_;
  int32_t faults_;
  uint8_t resetOccured_;
  int8_t padding2__;  int16_t padding3__;
  int32_t lastError_;
  int32_t controlMode_;
  double statorCurrent_;
  double supplyCurrent_;
  int32_t fwdLimitSwitchClosed_;
  int32_t revLimitSwitchClosed_;

 public:
  CTREMotorStatusFrame() {
    memset(static_cast<void *>(this), 0, sizeof(CTREMotorStatusFrame));
  }
  CTREMotorStatusFrame(int32_t _firmwareVersion, int32_t _baseID, int32_t _deviceID, double _outputCurrent, double _busVoltage, double _outputPercent, double _outputVoltage, double _temperature, int32_t _selectedSensorPosition, int32_t _selectedSensorVelocity, int32_t _closedLoopError, double _integralAccumulator, double _errorDerivative, double _closedLoopTarget, int32_t _activeTrajectoryPosition, int32_t _activeTrajectoryVelocity, double _activeTrajectoryArbFeedFwd, int32_t _faults, bool _resetOccured, int32_t _lastError, int32_t _controlMode, double _statorCurrent, double _supplyCurrent, int32_t _fwdLimitSwitchClosed, int32_t _revLimitSwitchClosed)
      : firmwareVersion_(flatbuffers::EndianScalar(_firmwareVersion)),
        baseID_(flatbuffers::EndianScalar(_baseID)),
        deviceID_(flatbuffers::EndianScalar(_deviceID)),
        padding0__(0),
        outputCurrent_(flatbuffers::EndianScalar(_outputCurrent)),
        busVoltage_(flatbuffers::EndianScalar(_busVoltage)),
        outputPercent_(flatbuffers::EndianScalar(_outputPercent)),
        outputVoltage_(flatbuffers::EndianScalar(_outputVoltage)),
        temperature_(flatbuffers::EndianScalar(_temperature)),
        selectedSensorPosition_(flatbuffers::EndianScalar(_selectedSensorPosition)),
        selectedSensorVelocity_(flatbuffers::EndianScalar(_selectedSensorVelocity)),
        closedLoopError_(flatbuffers::EndianScalar(_closedLoopError)),
        padding1__(0),
        integralAccumulator_(flatbuffers::EndianScalar(_integralAccumulator)),
        errorDerivative_(flatbuffers::EndianScalar(_errorDerivative)),
        closedLoopTarget_(flatbuffers::EndianScalar(_closedLoopTarget)),
        activeTrajectoryPosition_(flatbuffers::EndianScalar(_activeTrajectoryPosition)),
        activeTrajectoryVelocity_(flatbuffers::EndianScalar(_activeTrajectoryVelocity)),
        activeTrajectoryArbFeedFwd_(flatbuffers::EndianScalar(_activeTrajectoryArbFeedFwd)),
        faults_(flatbuffers::EndianScalar(_faults)),
        resetOccured_(flatbuffers::EndianScalar(static_cast<uint8_t>(_resetOccured))),
        padding2__(0),
        padding3__(0),
        lastError_(flatbuffers::EndianScalar(_lastError)),
        controlMode_(flatbuffers::EndianScalar(_controlMode)),
        statorCurrent_(flatbuffers::EndianScalar(_statorCurrent)),
        supplyCurrent_(flatbuffers::EndianScalar(_supplyCurrent)),
        fwdLimitSwitchClosed_(flatbuffers::EndianScalar(_fwdLimitSwitchClosed)),
        revLimitSwitchClosed_(flatbuffers::EndianScalar(_revLimitSwitchClosed)) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;    (void)padding3__;
  }
  int32_t firmwareVersion() const {
    return flatbuffers::EndianScalar(firmwareVersion_);
  }
  int32_t baseID() const {
    return flatbuffers::EndianScalar(baseID_);
  }
  int32_t deviceID() const {
    return flatbuffers::EndianScalar(deviceID_);
  }
  double outputCurrent() const {
    return flatbuffers::EndianScalar(outputCurrent_);
  }
  double busVoltage() const {
    return flatbuffers::EndianScalar(busVoltage_);
  }
  double outputPercent() const {
    return flatbuffers::EndianScalar(outputPercent_);
  }
  double outputVoltage() const {
    return flatbuffers::EndianScalar(outputVoltage_);
  }
  double temperature() const {
    return flatbuffers::EndianScalar(temperature_);
  }
  int32_t selectedSensorPosition() const {
    return flatbuffers::EndianScalar(selectedSensorPosition_);
  }
  int32_t selectedSensorVelocity() const {
    return flatbuffers::EndianScalar(selectedSensorVelocity_);
  }
  int32_t closedLoopError() const {
    return flatbuffers::EndianScalar(closedLoopError_);
  }
  double integralAccumulator() const {
    return flatbuffers::EndianScalar(integralAccumulator_);
  }
  double errorDerivative() const {
    return flatbuffers::EndianScalar(errorDerivative_);
  }
  double closedLoopTarget() const {
    return flatbuffers::EndianScalar(closedLoopTarget_);
  }
  int32_t activeTrajectoryPosition() const {
    return flatbuffers::EndianScalar(activeTrajectoryPosition_);
  }
  int32_t activeTrajectoryVelocity() const {
    return flatbuffers::EndianScalar(activeTrajectoryVelocity_);
  }
  double activeTrajectoryArbFeedFwd() const {
    return flatbuffers::EndianScalar(activeTrajectoryArbFeedFwd_);
  }
  int32_t faults() const {
    return flatbuffers::EndianScalar(faults_);
  }
  bool resetOccured() const {
    return flatbuffers::EndianScalar(resetOccured_) != 0;
  }
  int32_t lastError() const {
    return flatbuffers::EndianScalar(lastError_);
  }
  int32_t controlMode() const {
    return flatbuffers::EndianScalar(controlMode_);
  }
  double statorCurrent() const {
    return flatbuffers::EndianScalar(statorCurrent_);
  }
  double supplyCurrent() const {
    return flatbuffers::EndianScalar(supplyCurrent_);
  }
  int32_t fwdLimitSwitchClosed() const {
    return flatbuffers::EndianScalar(fwdLimitSwitchClosed_);
  }
  int32_t revLimitSwitchClosed() const {
    return flatbuffers::EndianScalar(revLimitSwitchClosed_);
  }
};
FLATBUFFERS_STRUCT_END(CTREMotorStatusFrame, 152);

struct StatusFrameCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DRIVELEFT1 = 4,
    VT_DRIVELEFT2 = 6,
    VT_DRIVERIGHT1 = 8,
    VT_DRIVERIGHT2 = 10
  };
  const CTREMotorStatusFrame *driveLeft1() const {
    return GetStruct<const CTREMotorStatusFrame *>(VT_DRIVELEFT1);
  }
  const CTREMotorStatusFrame *driveLeft2() const {
    return GetStruct<const CTREMotorStatusFrame *>(VT_DRIVELEFT2);
  }
  const CTREMotorStatusFrame *driveRight1() const {
    return GetStruct<const CTREMotorStatusFrame *>(VT_DRIVERIGHT1);
  }
  const CTREMotorStatusFrame *driveRight2() const {
    return GetStruct<const CTREMotorStatusFrame *>(VT_DRIVERIGHT2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<CTREMotorStatusFrame>(verifier, VT_DRIVELEFT1) &&
           VerifyField<CTREMotorStatusFrame>(verifier, VT_DRIVELEFT2) &&
           VerifyField<CTREMotorStatusFrame>(verifier, VT_DRIVERIGHT1) &&
           VerifyField<CTREMotorStatusFrame>(verifier, VT_DRIVERIGHT2) &&
           verifier.EndTable();
  }
};

struct StatusFrameCollectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_driveLeft1(const CTREMotorStatusFrame *driveLeft1) {
    fbb_.AddStruct(StatusFrameCollection::VT_DRIVELEFT1, driveLeft1);
  }
  void add_driveLeft2(const CTREMotorStatusFrame *driveLeft2) {
    fbb_.AddStruct(StatusFrameCollection::VT_DRIVELEFT2, driveLeft2);
  }
  void add_driveRight1(const CTREMotorStatusFrame *driveRight1) {
    fbb_.AddStruct(StatusFrameCollection::VT_DRIVERIGHT1, driveRight1);
  }
  void add_driveRight2(const CTREMotorStatusFrame *driveRight2) {
    fbb_.AddStruct(StatusFrameCollection::VT_DRIVERIGHT2, driveRight2);
  }
  explicit StatusFrameCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatusFrameCollectionBuilder &operator=(const StatusFrameCollectionBuilder &);
  flatbuffers::Offset<StatusFrameCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusFrameCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusFrameCollection> CreateStatusFrameCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    const CTREMotorStatusFrame *driveLeft1 = 0,
    const CTREMotorStatusFrame *driveLeft2 = 0,
    const CTREMotorStatusFrame *driveRight1 = 0,
    const CTREMotorStatusFrame *driveRight2 = 0) {
  StatusFrameCollectionBuilder builder_(_fbb);
  builder_.add_driveRight2(driveRight2);
  builder_.add_driveRight1(driveRight1);
  builder_.add_driveLeft2(driveLeft2);
  builder_.add_driveLeft1(driveLeft1);
  return builder_.Finish();
}

}  // namespace rj

#endif  // FLATBUFFERS_GENERATED_STATUSFRAME_RJ_H_
