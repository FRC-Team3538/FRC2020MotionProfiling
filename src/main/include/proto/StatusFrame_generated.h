// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_STATUSFRAME_RJ_H_
#define FLATBUFFERS_GENERATED_STATUSFRAME_RJ_H_

#include "flatbuffers/flatbuffers.h"

namespace rj {

struct CTREMotorStatusFrame;

struct PDPStatusFrame;

struct PCMStatusFrame;

struct StatusFrameCollection;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8)
CTREMotorStatusFrame FLATBUFFERS_FINAL_CLASS
{
private:
  int32_t firmwareVersion_;
  int32_t baseID_;
  int32_t deviceID_;
  int32_t padding0__;
  double outputCurrent_;
  double busVoltage_;
  double outputPercent_;
  double outputVoltage_;
  double temperature_;
  int32_t selectedSensorPosition_;
  int32_t selectedSensorVelocity_;
  int32_t closedLoopError_;
  int32_t padding1__;
  double integralAccumulator_;
  double errorDerivative_;
  double closedLoopTarget_;
  int32_t activeTrajectoryPosition_;
  int32_t activeTrajectoryVelocity_;
  double activeTrajectoryArbFeedFwd_;
  int32_t faults_;
  uint8_t resetOccured_;
  int8_t padding2__;
  int16_t padding3__;
  int32_t lastError_;
  int32_t controlMode_;
  double statorCurrent_;
  double supplyCurrent_;
  int32_t fwdLimitSwitchClosed_;
  int32_t revLimitSwitchClosed_;

public:
  CTREMotorStatusFrame()
  {
    memset(static_cast<void*>(this), 0, sizeof(CTREMotorStatusFrame));
  }
  CTREMotorStatusFrame(int32_t _firmwareVersion,
                       int32_t _baseID,
                       int32_t _deviceID,
                       double _outputCurrent,
                       double _busVoltage,
                       double _outputPercent,
                       double _outputVoltage,
                       double _temperature,
                       int32_t _selectedSensorPosition,
                       int32_t _selectedSensorVelocity,
                       int32_t _closedLoopError,
                       double _integralAccumulator,
                       double _errorDerivative,
                       double _closedLoopTarget,
                       int32_t _activeTrajectoryPosition,
                       int32_t _activeTrajectoryVelocity,
                       double _activeTrajectoryArbFeedFwd,
                       int32_t _faults,
                       bool _resetOccured,
                       int32_t _lastError,
                       int32_t _controlMode,
                       double _statorCurrent,
                       double _supplyCurrent,
                       int32_t _fwdLimitSwitchClosed,
                       int32_t _revLimitSwitchClosed)
    : firmwareVersion_(flatbuffers::EndianScalar(_firmwareVersion))
    , baseID_(flatbuffers::EndianScalar(_baseID))
    , deviceID_(flatbuffers::EndianScalar(_deviceID))
    , padding0__(0)
    , outputCurrent_(flatbuffers::EndianScalar(_outputCurrent))
    , busVoltage_(flatbuffers::EndianScalar(_busVoltage))
    , outputPercent_(flatbuffers::EndianScalar(_outputPercent))
    , outputVoltage_(flatbuffers::EndianScalar(_outputVoltage))
    , temperature_(flatbuffers::EndianScalar(_temperature))
    , selectedSensorPosition_(
        flatbuffers::EndianScalar(_selectedSensorPosition))
    , selectedSensorVelocity_(
        flatbuffers::EndianScalar(_selectedSensorVelocity))
    , closedLoopError_(flatbuffers::EndianScalar(_closedLoopError))
    , padding1__(0)
    , integralAccumulator_(flatbuffers::EndianScalar(_integralAccumulator))
    , errorDerivative_(flatbuffers::EndianScalar(_errorDerivative))
    , closedLoopTarget_(flatbuffers::EndianScalar(_closedLoopTarget))
    , activeTrajectoryPosition_(
        flatbuffers::EndianScalar(_activeTrajectoryPosition))
    , activeTrajectoryVelocity_(
        flatbuffers::EndianScalar(_activeTrajectoryVelocity))
    , activeTrajectoryArbFeedFwd_(
        flatbuffers::EndianScalar(_activeTrajectoryArbFeedFwd))
    , faults_(flatbuffers::EndianScalar(_faults))
    , resetOccured_(
        flatbuffers::EndianScalar(static_cast<uint8_t>(_resetOccured)))
    , padding2__(0)
    , padding3__(0)
    , lastError_(flatbuffers::EndianScalar(_lastError))
    , controlMode_(flatbuffers::EndianScalar(_controlMode))
    , statorCurrent_(flatbuffers::EndianScalar(_statorCurrent))
    , supplyCurrent_(flatbuffers::EndianScalar(_supplyCurrent))
    , fwdLimitSwitchClosed_(flatbuffers::EndianScalar(_fwdLimitSwitchClosed))
    , revLimitSwitchClosed_(flatbuffers::EndianScalar(_revLimitSwitchClosed))
  {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  int32_t firmwareVersion() const
  {
    return flatbuffers::EndianScalar(firmwareVersion_);
  }
  int32_t baseID() const { return flatbuffers::EndianScalar(baseID_); }
  int32_t deviceID() const { return flatbuffers::EndianScalar(deviceID_); }
  double outputCurrent() const
  {
    return flatbuffers::EndianScalar(outputCurrent_);
  }
  double busVoltage() const { return flatbuffers::EndianScalar(busVoltage_); }
  double outputPercent() const
  {
    return flatbuffers::EndianScalar(outputPercent_);
  }
  double outputVoltage() const
  {
    return flatbuffers::EndianScalar(outputVoltage_);
  }
  double temperature() const { return flatbuffers::EndianScalar(temperature_); }
  int32_t selectedSensorPosition() const
  {
    return flatbuffers::EndianScalar(selectedSensorPosition_);
  }
  int32_t selectedSensorVelocity() const
  {
    return flatbuffers::EndianScalar(selectedSensorVelocity_);
  }
  int32_t closedLoopError() const
  {
    return flatbuffers::EndianScalar(closedLoopError_);
  }
  double integralAccumulator() const
  {
    return flatbuffers::EndianScalar(integralAccumulator_);
  }
  double errorDerivative() const
  {
    return flatbuffers::EndianScalar(errorDerivative_);
  }
  double closedLoopTarget() const
  {
    return flatbuffers::EndianScalar(closedLoopTarget_);
  }
  int32_t activeTrajectoryPosition() const
  {
    return flatbuffers::EndianScalar(activeTrajectoryPosition_);
  }
  int32_t activeTrajectoryVelocity() const
  {
    return flatbuffers::EndianScalar(activeTrajectoryVelocity_);
  }
  double activeTrajectoryArbFeedFwd() const
  {
    return flatbuffers::EndianScalar(activeTrajectoryArbFeedFwd_);
  }
  int32_t faults() const { return flatbuffers::EndianScalar(faults_); }
  bool resetOccured() const
  {
    return flatbuffers::EndianScalar(resetOccured_) != 0;
  }
  int32_t lastError() const { return flatbuffers::EndianScalar(lastError_); }
  int32_t controlMode() const
  {
    return flatbuffers::EndianScalar(controlMode_);
  }
  double statorCurrent() const
  {
    return flatbuffers::EndianScalar(statorCurrent_);
  }
  double supplyCurrent() const
  {
    return flatbuffers::EndianScalar(supplyCurrent_);
  }
  int32_t fwdLimitSwitchClosed() const
  {
    return flatbuffers::EndianScalar(fwdLimitSwitchClosed_);
  }
  int32_t revLimitSwitchClosed() const
  {
    return flatbuffers::EndianScalar(revLimitSwitchClosed_);
  }
};
FLATBUFFERS_STRUCT_END(CTREMotorStatusFrame, 152);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PDPStatusFrame FLATBUFFERS_FINAL_CLASS
{
private:
  int32_t module__;
  int32_t padding0__;
  double voltage_;
  double temperature_;
  double channel0Current_;
  double channel1Current_;
  double channel2Current_;
  double channel3Current_;
  double channel4Current_;
  double channel5Current_;
  double channel6Current_;
  double channel7Current_;
  double channel8Current_;
  double channel9Current_;
  double channel10Current_;
  double channel11Current_;
  double channel12Current_;
  double channel13Current_;
  double channel14Current_;
  double channel15Current_;
  double totalCurrent_;
  double totalPower_;
  double totalEnergy_;

public:
  PDPStatusFrame()
  {
    memset(static_cast<void*>(this), 0, sizeof(PDPStatusFrame));
  }
  PDPStatusFrame(int32_t _module_,
                 double _voltage,
                 double _temperature,
                 double _channel0Current,
                 double _channel1Current,
                 double _channel2Current,
                 double _channel3Current,
                 double _channel4Current,
                 double _channel5Current,
                 double _channel6Current,
                 double _channel7Current,
                 double _channel8Current,
                 double _channel9Current,
                 double _channel10Current,
                 double _channel11Current,
                 double _channel12Current,
                 double _channel13Current,
                 double _channel14Current,
                 double _channel15Current,
                 double _totalCurrent,
                 double _totalPower,
                 double _totalEnergy)
    : module__(flatbuffers::EndianScalar(_module_))
    , padding0__(0)
    , voltage_(flatbuffers::EndianScalar(_voltage))
    , temperature_(flatbuffers::EndianScalar(_temperature))
    , channel0Current_(flatbuffers::EndianScalar(_channel0Current))
    , channel1Current_(flatbuffers::EndianScalar(_channel1Current))
    , channel2Current_(flatbuffers::EndianScalar(_channel2Current))
    , channel3Current_(flatbuffers::EndianScalar(_channel3Current))
    , channel4Current_(flatbuffers::EndianScalar(_channel4Current))
    , channel5Current_(flatbuffers::EndianScalar(_channel5Current))
    , channel6Current_(flatbuffers::EndianScalar(_channel6Current))
    , channel7Current_(flatbuffers::EndianScalar(_channel7Current))
    , channel8Current_(flatbuffers::EndianScalar(_channel8Current))
    , channel9Current_(flatbuffers::EndianScalar(_channel9Current))
    , channel10Current_(flatbuffers::EndianScalar(_channel10Current))
    , channel11Current_(flatbuffers::EndianScalar(_channel11Current))
    , channel12Current_(flatbuffers::EndianScalar(_channel12Current))
    , channel13Current_(flatbuffers::EndianScalar(_channel13Current))
    , channel14Current_(flatbuffers::EndianScalar(_channel14Current))
    , channel15Current_(flatbuffers::EndianScalar(_channel15Current))
    , totalCurrent_(flatbuffers::EndianScalar(_totalCurrent))
    , totalPower_(flatbuffers::EndianScalar(_totalPower))
    , totalEnergy_(flatbuffers::EndianScalar(_totalEnergy))
  {
    (void)padding0__;
  }
  int32_t module_() const { return flatbuffers::EndianScalar(module__); }
  double voltage() const { return flatbuffers::EndianScalar(voltage_); }
  double temperature() const { return flatbuffers::EndianScalar(temperature_); }
  double channel0Current() const
  {
    return flatbuffers::EndianScalar(channel0Current_);
  }
  double channel1Current() const
  {
    return flatbuffers::EndianScalar(channel1Current_);
  }
  double channel2Current() const
  {
    return flatbuffers::EndianScalar(channel2Current_);
  }
  double channel3Current() const
  {
    return flatbuffers::EndianScalar(channel3Current_);
  }
  double channel4Current() const
  {
    return flatbuffers::EndianScalar(channel4Current_);
  }
  double channel5Current() const
  {
    return flatbuffers::EndianScalar(channel5Current_);
  }
  double channel6Current() const
  {
    return flatbuffers::EndianScalar(channel6Current_);
  }
  double channel7Current() const
  {
    return flatbuffers::EndianScalar(channel7Current_);
  }
  double channel8Current() const
  {
    return flatbuffers::EndianScalar(channel8Current_);
  }
  double channel9Current() const
  {
    return flatbuffers::EndianScalar(channel9Current_);
  }
  double channel10Current() const
  {
    return flatbuffers::EndianScalar(channel10Current_);
  }
  double channel11Current() const
  {
    return flatbuffers::EndianScalar(channel11Current_);
  }
  double channel12Current() const
  {
    return flatbuffers::EndianScalar(channel12Current_);
  }
  double channel13Current() const
  {
    return flatbuffers::EndianScalar(channel13Current_);
  }
  double channel14Current() const
  {
    return flatbuffers::EndianScalar(channel14Current_);
  }
  double channel15Current() const
  {
    return flatbuffers::EndianScalar(channel15Current_);
  }
  double totalCurrent() const
  {
    return flatbuffers::EndianScalar(totalCurrent_);
  }
  double totalPower() const { return flatbuffers::EndianScalar(totalPower_); }
  double totalEnergy() const { return flatbuffers::EndianScalar(totalEnergy_); }
};
FLATBUFFERS_STRUCT_END(PDPStatusFrame, 176);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PCMStatusFrame FLATBUFFERS_FINAL_CLASS
{
private:
  int32_t module__;
  uint8_t enabled_;
  uint8_t pressureSwitchValve_;
  int16_t padding0__;
  double compressorCurrent_;
  uint8_t closedLoopControl_;
  uint8_t compressorCurrentTooHighFault_;
  uint8_t compressorShortedFault_;
  uint8_t compressorNotConnectedFault_;
  int32_t padding1__;

public:
  PCMStatusFrame()
  {
    memset(static_cast<void*>(this), 0, sizeof(PCMStatusFrame));
  }
  PCMStatusFrame(int32_t _module_,
                 bool _enabled,
                 bool _pressureSwitchValve,
                 double _compressorCurrent,
                 bool _closedLoopControl,
                 bool _compressorCurrentTooHighFault,
                 bool _compressorShortedFault,
                 bool _compressorNotConnectedFault)
    : module__(flatbuffers::EndianScalar(_module_))
    , enabled_(flatbuffers::EndianScalar(static_cast<uint8_t>(_enabled)))
    , pressureSwitchValve_(
        flatbuffers::EndianScalar(static_cast<uint8_t>(_pressureSwitchValve)))
    , padding0__(0)
    , compressorCurrent_(flatbuffers::EndianScalar(_compressorCurrent))
    , closedLoopControl_(
        flatbuffers::EndianScalar(static_cast<uint8_t>(_closedLoopControl)))
    , compressorCurrentTooHighFault_(flatbuffers::EndianScalar(
        static_cast<uint8_t>(_compressorCurrentTooHighFault)))
    , compressorShortedFault_(flatbuffers::EndianScalar(
        static_cast<uint8_t>(_compressorShortedFault)))
    , compressorNotConnectedFault_(flatbuffers::EndianScalar(
        static_cast<uint8_t>(_compressorNotConnectedFault)))
    , padding1__(0)
  {
    (void)padding0__;
    (void)padding1__;
  }
  int32_t module_() const { return flatbuffers::EndianScalar(module__); }
  bool enabled() const { return flatbuffers::EndianScalar(enabled_) != 0; }
  bool pressureSwitchValve() const
  {
    return flatbuffers::EndianScalar(pressureSwitchValve_) != 0;
  }
  double compressorCurrent() const
  {
    return flatbuffers::EndianScalar(compressorCurrent_);
  }
  bool closedLoopControl() const
  {
    return flatbuffers::EndianScalar(closedLoopControl_) != 0;
  }
  bool compressorCurrentTooHighFault() const
  {
    return flatbuffers::EndianScalar(compressorCurrentTooHighFault_) != 0;
  }
  bool compressorShortedFault() const
  {
    return flatbuffers::EndianScalar(compressorShortedFault_) != 0;
  }
  bool compressorNotConnectedFault() const
  {
    return flatbuffers::EndianScalar(compressorNotConnectedFault_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(PCMStatusFrame, 24);

struct StatusFrameCollection FLATBUFFERS_FINAL_CLASS
  : private flatbuffers::Table
{
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
  {
    VT_DRIVELEFT1 = 4,
    VT_DRIVELEFT2 = 6,
    VT_DRIVERIGHT1 = 8,
    VT_DRIVERIGHT2 = 10,
    VT_POWERDISTRIBUTIONPANEL = 12,
    VT_PNEUMATICSCONTROLMODULE = 14
  };
  const CTREMotorStatusFrame* driveLeft1() const
  {
    return GetStruct<const CTREMotorStatusFrame*>(VT_DRIVELEFT1);
  }
  const CTREMotorStatusFrame* driveLeft2() const
  {
    return GetStruct<const CTREMotorStatusFrame*>(VT_DRIVELEFT2);
  }
  const CTREMotorStatusFrame* driveRight1() const
  {
    return GetStruct<const CTREMotorStatusFrame*>(VT_DRIVERIGHT1);
  }
  const CTREMotorStatusFrame* driveRight2() const
  {
    return GetStruct<const CTREMotorStatusFrame*>(VT_DRIVERIGHT2);
  }
  const PDPStatusFrame* powerDistributionPanel() const
  {
    return GetStruct<const PDPStatusFrame*>(VT_POWERDISTRIBUTIONPANEL);
  }
  const PCMStatusFrame* pneumaticsControlModule() const
  {
    return GetStruct<const PCMStatusFrame*>(VT_PNEUMATICSCONTROLMODULE);
  }
  bool Verify(flatbuffers::Verifier& verifier) const
  {
    return VerifyTableStart(verifier) &&
           VerifyField<CTREMotorStatusFrame>(verifier, VT_DRIVELEFT1) &&
           VerifyField<CTREMotorStatusFrame>(verifier, VT_DRIVELEFT2) &&
           VerifyField<CTREMotorStatusFrame>(verifier, VT_DRIVERIGHT1) &&
           VerifyField<CTREMotorStatusFrame>(verifier, VT_DRIVERIGHT2) &&
           VerifyField<PDPStatusFrame>(verifier, VT_POWERDISTRIBUTIONPANEL) &&
           VerifyField<PCMStatusFrame>(verifier, VT_PNEUMATICSCONTROLMODULE) &&
           verifier.EndTable();
  }
};

struct StatusFrameCollectionBuilder
{
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_driveLeft1(const CTREMotorStatusFrame* driveLeft1)
  {
    fbb_.AddStruct(StatusFrameCollection::VT_DRIVELEFT1, driveLeft1);
  }
  void add_driveLeft2(const CTREMotorStatusFrame* driveLeft2)
  {
    fbb_.AddStruct(StatusFrameCollection::VT_DRIVELEFT2, driveLeft2);
  }
  void add_driveRight1(const CTREMotorStatusFrame* driveRight1)
  {
    fbb_.AddStruct(StatusFrameCollection::VT_DRIVERIGHT1, driveRight1);
  }
  void add_driveRight2(const CTREMotorStatusFrame* driveRight2)
  {
    fbb_.AddStruct(StatusFrameCollection::VT_DRIVERIGHT2, driveRight2);
  }
  void add_powerDistributionPanel(const PDPStatusFrame* powerDistributionPanel)
  {
    fbb_.AddStruct(StatusFrameCollection::VT_POWERDISTRIBUTIONPANEL,
                   powerDistributionPanel);
  }
  void add_pneumaticsControlModule(
    const PCMStatusFrame* pneumaticsControlModule)
  {
    fbb_.AddStruct(StatusFrameCollection::VT_PNEUMATICSCONTROLMODULE,
                   pneumaticsControlModule);
  }
  explicit StatusFrameCollectionBuilder(flatbuffers::FlatBufferBuilder& _fbb)
    : fbb_(_fbb)
  {
    start_ = fbb_.StartTable();
  }
  StatusFrameCollectionBuilder& operator=(const StatusFrameCollectionBuilder&);
  flatbuffers::Offset<StatusFrameCollection> Finish()
  {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusFrameCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusFrameCollection>
CreateStatusFrameCollection(flatbuffers::FlatBufferBuilder& _fbb,
                            const CTREMotorStatusFrame* driveLeft1 = 0,
                            const CTREMotorStatusFrame* driveLeft2 = 0,
                            const CTREMotorStatusFrame* driveRight1 = 0,
                            const CTREMotorStatusFrame* driveRight2 = 0,
                            const PDPStatusFrame* powerDistributionPanel = 0,
                            const PCMStatusFrame* pneumaticsControlModule = 0)
{
  StatusFrameCollectionBuilder builder_(_fbb);
  builder_.add_pneumaticsControlModule(pneumaticsControlModule);
  builder_.add_powerDistributionPanel(powerDistributionPanel);
  builder_.add_driveRight2(driveRight2);
  builder_.add_driveRight1(driveRight1);
  builder_.add_driveLeft2(driveLeft2);
  builder_.add_driveLeft1(driveLeft1);
  return builder_.Finish();
}

} // namespace rj

#endif // FLATBUFFERS_GENERATED_STATUSFRAME_RJ_H_
